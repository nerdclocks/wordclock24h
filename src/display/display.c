/*-------------------------------------------------------------------------------------------------------------------------------------------
 * display.c - routines for LED display 16x18 and 10x11
 *
 * Copyright (c) 2014-2016 Frank Meyer - frank(at)fli4l.de
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "wclock24h-config.h"

#if WCLOCK24H == 1
#include "tables.h"
#else
#include "tables12h.h"
#endif

#include "display.h"
#include "display-config.h"

#include "irmp.h"

#if DSP_USE_APA102
#include "apa102.h"
#define LED_RGB             APA102_RGB
#define led_init            apa102_init
#define led_refresh         apa102_refresh
#define led_set_led         apa102_set_led
#define led_set_all_leds    apa102_set_all_leds
#else
#include "ws2812.h"
#define LED_RGB             WS2812_RGB
#define led_init            ws2812_init
#define led_refresh         ws2812_refresh
#define led_set_led         ws2812_set_led
#define led_set_all_leds    ws2812_set_all_leds
#endif

#include "eeprom.h"
#include "eeprom-data.h"
#include "delay.h"
#include "ldr.h"

#define USE_FONT            0     // fm: TODO

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HERE IS A SHORT PROGRAM TO CALCULATE THE PWM TABLE:

//-----------------------------------------------------------------------------------------------------------------------------
// pwmtable[i] = floor(maxvalue * ((i / (steps - 1)) ^ (1/gamma))w + 0.5)
//
// See also:
// http://www.mikrocontroller.net/articles/Diskussion:LED-Fading#Diskussion_wissenschaftl.-technischer_Hintergrund
// http://www.maxim-ic.com/app-notes/index.mvp/id/3667
//
// Compile it with: cc gamma.c -o gamma -lm
//-----------------------------------------------------------------------------------------------------------------------------

#include <stdio.h>
#include <math.h>

#define STEPS       (64)            // CHANGE HERE
#define PWMBITS     (8)             // CHANGE HERE

// GAMMA:
// 0.5   für punktförmige oder aufblitzende Helligkeiten
// 0.33  für Lichtquellen bei 5° Blickwinkel
// 1/2.2 für diffus strahlende LEDs - entspricht der Gammakorrektur von VGA-Bildschirmen
#define GAMMA       (1/2.2)

int main ()
{
    int     maxvalue;
    double  value;
    int     i;

    maxvalue = (1 << PWMBITS) - 1;

    for (i = 0; i < STEPS; i++)
    {
        value = floor ((double) maxvalue * pow ((double) i / (double) (STEPS - 1), 1/(GAMMA)) + 0.5);
        if (i > 0 && value < 1)
        {
            value = 1;
        }

        printf ("%5.0f", value);

        if (i < STEPS - 1)
        {
            putchar (',');
            putchar (' ');
        }

        if (!((i + 1) % 8))
        {
            putchar ('\n');
        }
    }
}

 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

#define MAX_COLOR_STEPS     64


/*-------------------------------------------------------------------------------------------------------------------------------------------
 * 8-Bit PWM with 64 different settings:
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static const uint16_t pwmtable8[MAX_COLOR_STEPS]  =
{
    0,     1,     1,     2,     2,     3,     3,     4,
    4,     5,     5,     6,     7,     8,     9,    11,
   13,    14,    16,    18,    20,    23,    25,    28,
   31,    33,    36,    40,    43,    46,    50,    54,
   57,    61,    66,    70,    74,    79,    84,    89,
   94,    99,   105,   110,   116,   122,   128,   134,
  140,   147,   153,   160,   167,   174,   182,   189,
  197,   205,   213,   221,   229,   238,   246,   255
};

static DSP_COLORS   current_colors =
{
    MAX_COLOR_STEPS / 2, 0, 0
};

static DSP_COLORS   dimmed_colors =
{
    MAX_COLOR_STEPS / 2, 0, 0
};

static uint_fast8_t                 display_mode;

static DSP_COLORS                   dimmed_colors_up;
static DSP_COLORS                   dimmed_colors_down;

static uint_fast8_t                 brightness = MAX_BRIGHTNESS;
static uint_fast8_t                 automatic_brightness_control = 0;

#define CURRENT_STATE               0x01
#define TARGET_STATE                0x02
#define NEW_STATE                   0x04
#define CALC_STATE                  0x08

#define ANIMATION_MODE_NONE         0
#define ANIMATION_MODE_FADE         1
#define ANIMATION_MODE_ROLL         2
#define ANIMATION_MODE_EXPLODE      3
#define ANIMATION_MODE_RANDOM       4
#define ANIMATION_MODES             5

const char *                        animation_modes[ANIMATION_MODES] =
{
    "None",
    "Fade",
    "Roll",
    "Explode",
    "Random"
};

static uint_fast8_t                 animation_mode = ANIMATION_MODE_FADE;
static uint_fast8_t                 animation_start_flag;
static uint_fast8_t                 animation_stop_flag;

union
{
    uint8_t                         state[DSP_DISPLAY_LEDS];
    uint8_t                         matrix[WC_ROWS][WC_COLUMNS];
} led;

static uint_fast8_t                 red_step;
static uint_fast8_t                 green_step;
static uint_fast8_t                 blue_step;

#define BANNER_LINES                8
#define BANNER_COLS                 8

#define BANNER_DEGREE               1
#define BANNER_A_UMLAUT             2
#define BANNER_O_UMLAUT             3
#define BANNER_U_UMLAUT             4
#define BANNER_SHARP_S              5

static const char banner[128][8] =                          // only 7 Bit ASCII + some special characters
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //   0
    { 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 },     //   1 degree
    { 0x24, 0x18, 0x24, 0x42, 0x7e, 0x42, 0x42, 0x00 },     //   2 a umlaut
    { 0x24, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x3c, 0x00 },     //   3 o umlaut
    { 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00 },     //   4 u umlaut
    { 0x7C, 0x42, 0x7C, 0x42, 0x7C, 0x40, 0x40, 0x00 },     //   5 sharp s
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //   6
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //   7
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //   8
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //   9
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  10
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  11
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  12
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  13
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  14
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  15
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  16
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  17
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  18
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  19
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  21
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  22
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  24
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  25
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  26
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  27
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  28
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  29
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  30
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  31
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  32
    { 0x38, 0x38, 0x38, 0x10, 0x00, 0x38, 0x38, 0x00 },     //  33 !
    { 0xee, 0xee, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  34 "
    { 0x28, 0x28, 0xfe, 0x28, 0xfe, 0x28, 0x28, 0x00 },     //  35 #
    { 0x7c, 0x92, 0x90, 0x7c, 0x12, 0x92, 0x7c, 0x00 },     //  36 $
    { 0xe2, 0xa4, 0xe8, 0x10, 0x2e, 0x4a, 0x8e, 0x00 },     //  37 %
    { 0x30, 0x48, 0x30, 0x70, 0x8a, 0x84, 0x7a, 0x00 },     //  38 &
    { 0x38, 0x38, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00 },     //  39 '
    { 0x18, 0x20, 0x40, 0x40, 0x40, 0x20, 0x18, 0x00 },     //  40 (
    { 0x30, 0x08, 0x04, 0x04, 0x04, 0x08, 0x30, 0x00 },     //  41 )
    { 0x00, 0x44, 0x28, 0xee, 0x28, 0x44, 0x00, 0x00 },     //  42 *
    { 0x00, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x00, 0x00 },     //  43 +
    { 0x00, 0x00, 0x00, 0x38, 0x38, 0x10, 0x20, 0x00 },     //  44 ,
    { 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00 },     //  45 -
    { 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x38, 0x00 },     //  46 .
    { 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00 },     //  47 /
    { 0x38, 0x44, 0xa2, 0x92, 0x8a, 0x44, 0x38, 0x00 },     //  48 0
    { 0x10, 0x30, 0x50, 0x10, 0x10, 0x10, 0x7c, 0x00 },     //  49 1
    { 0x7c, 0x82, 0x02, 0x7c, 0x80, 0x80, 0xfe, 0x00 },     //  50 2
    { 0x7c, 0x82, 0x02, 0x7c, 0x02, 0x82, 0x7c, 0x00 },     //  51 3
    { 0x80, 0x84, 0x84, 0xfe, 0x04, 0x04, 0x04, 0x00 },     //  52 4
    { 0xfe, 0x80, 0x80, 0x7c, 0x02, 0x82, 0x7c, 0x00 },     //  53 5
    { 0x7c, 0x82, 0x80, 0xfc, 0x82, 0x82, 0x7c, 0x00 },     //  54 6
    { 0xfe, 0x84, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00 },     //  55 7
    { 0x7c, 0x82, 0x82, 0x7c, 0x82, 0x82, 0x7c, 0x00 },     //  56 8
    { 0x7c, 0x82, 0x82, 0x7e, 0x02, 0x82, 0x7c, 0x00 },     //  57 9
    { 0x10, 0x28, 0x10, 0x00, 0x10, 0x28, 0x10, 0x00 },     //  58 :
    { 0x38, 0x38, 0x00, 0x38, 0x38, 0x10, 0x20, 0x00 },     //  59 ;
    { 0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x00 },     //  60 <
    { 0x00, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x00, 0x00 },     //  61 =
    { 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00 },     //  62 >
    { 0x7c, 0x82, 0x02, 0x0c, 0x10, 0x00, 0x10, 0x00 },     //  63 ?
    { 0x7c, 0x82, 0xba, 0xaa, 0xbc, 0x82, 0x7c, 0x00 },     //  64 @
    { 0x10, 0x28, 0x44, 0x82, 0xfe, 0x82, 0x82, 0x00 },     //  65 A
    { 0xfc, 0x82, 0x82, 0xfc, 0x82, 0x82, 0xfc, 0x00 },     //  66 B
    { 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x00 },     //  67 C
    { 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00 },     //  68 D
    { 0xfe, 0x80, 0x80, 0xf8, 0x80, 0x80, 0xfe, 0x00 },     //  69 E
    { 0xfe, 0x80, 0x80, 0xf8, 0x80, 0x80, 0x80, 0x00 },     //  70 F
    { 0x7c, 0x82, 0x80, 0x9e, 0x82, 0x82, 0x7c, 0x00 },     //  71 G
    { 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x00 },     //  72 H
    { 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00 },     //  73 I
    { 0x02, 0x02, 0x02, 0x02, 0x82, 0x82, 0x7c, 0x00 },     //  74 J
    { 0x84, 0x88, 0x90, 0xe0, 0x90, 0x88, 0x84, 0x00 },     //  75 K
    { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xfe, 0x00 },     //  76 L
    { 0x82, 0xc6, 0xaa, 0x92, 0x82, 0x82, 0x82, 0x00 },     //  77 M
    { 0x82, 0xc2, 0xa2, 0x92, 0x8a, 0x86, 0x82, 0x00 },     //  78 N
    { 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00 },     //  79 O fm: 0xfe -> 0x7c
    { 0xfc, 0x82, 0x82, 0xfc, 0x80, 0x80, 0x80, 0x00 },     //  80 P
    { 0x7c, 0x82, 0x82, 0x82, 0x8a, 0x84, 0x7a, 0x00 },     //  81 Q
    { 0xfc, 0x82, 0x82, 0xfc, 0x88, 0x84, 0x82, 0x00 },     //  82 R
    { 0x7c, 0x82, 0x80, 0x7c, 0x02, 0x82, 0x7c, 0x00 },     //  83 S
    { 0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00 },     //  84 T
    { 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00 },     //  85 U
    { 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00 },     //  86 V
    { 0x82, 0x92, 0x92, 0x92, 0x92, 0x92, 0x6c, 0x00 },     //  87 W
    { 0x82, 0x44, 0x28, 0x10, 0x28, 0x44, 0x82, 0x00 },     //  88 X
    { 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00 },     //  89 Y
    { 0xfe, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfe, 0x00 },     //  90 Z
    { 0x7c, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7c, 0x00 },     //  91 [
    { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00 },     //  92 backslash
    { 0x7c, 0x04, 0x04, 0x04, 0x04, 0x04, 0x7c, 0x00 },     //  93 ]
    { 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00 },     //  94 ^
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00 },     //  95 _
    { 0x38, 0x38, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00 },     //  96 `
    { 0x00, 0x18, 0x24, 0x42, 0x7e, 0x42, 0x42, 0x00 },     //  97 a
    { 0x00, 0x7c, 0x42, 0x7c, 0x42, 0x42, 0x7c, 0x00 },     //  98 b
    { 0x00, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c, 0x00 },     //  99 c
    { 0x00, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x7c, 0x00 },     // 100 d
    { 0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x7e, 0x00 },     // 101 e
    { 0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x00 },     // 102 f
    { 0x00, 0x3c, 0x42, 0x40, 0x4e, 0x42, 0x3c, 0x00 },     // 103 g
    { 0x00, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x00 },     // 104 h
    { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 },     // 105 i
    { 0x00, 0x02, 0x02, 0x02, 0x02, 0x42, 0x3c, 0x00 },     // 106 j
    { 0x00, 0x42, 0x44, 0x78, 0x48, 0x44, 0x42, 0x00 },     // 107 k
    { 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00 },     // 108 l
    { 0x00, 0x42, 0x66, 0x5a, 0x42, 0x42, 0x42, 0x00 },     // 109 m
    { 0x00, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00 },     // 110 n
    { 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00 },     // 111 o
    { 0x00, 0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x00 },     // 112 p
    { 0x00, 0x3c, 0x42, 0x42, 0x4a, 0x44, 0x3a, 0x00 },     // 113 q
    { 0x00, 0x7c, 0x42, 0x42, 0x7c, 0x44, 0x42, 0x00 },     // 114 r
    { 0x00, 0x3c, 0x40, 0x3c, 0x02, 0x42, 0x3c, 0x00 },     // 115 s
    { 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 },     // 116 t
    { 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00 },     // 117 u
    { 0x00, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00 },     // 118 v
    { 0x00, 0x42, 0x42, 0x42, 0x5a, 0x66, 0x42, 0x00 },     // 119 w
    { 0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00 },     // 120 x
    { 0x00, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00 },     // 121 y
    { 0x00, 0x7e, 0x04, 0x08, 0x10, 0x20, 0x7e, 0x00 },     // 122 z
    { 0x38, 0x40, 0x40, 0xc0, 0x40, 0x40, 0x38, 0x00 },     // 123 {
    { 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x10, 0x00 },     // 124 |
    { 0x38, 0x04, 0x04, 0x06, 0x04, 0x04, 0x38, 0x00 },     // 125 }
    { 0x60, 0x92, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00 },     // 126 ~
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }      // 127 DEL
};


#if USE_FONT == 1
#define FONT_LINES                  12
#define FONT_COLS                    7

static const char font[256][FONT_LINES] =
{
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x00
    {0x00,0x00,0x00,0x1C,0x63,0x55,0x7F,0x63,0x1C,0x00,0x00,0x00},  // 0x01
    {0x00,0x00,0x00,0x1C,0x7F,0x6B,0x7F,0x63,0x1C,0x00,0x00,0x00},  // 0x02
    {0x00,0x36,0x7F,0x7F,0x7F,0x3E,0x3E,0x1C,0x08,0x00,0x00,0x00},  // 0x03
    {0x00,0x08,0x1C,0x3E,0x7F,0x3E,0x1C,0x08,0x08,0x00,0x00,0x00},  // 0x04
    {0x00,0x1C,0x1C,0x1C,0x7F,0x7F,0x7F,0x0C,0x0C,0x00,0x00,0x00},  // 0x05
    {0x00,0x08,0x1C,0x3E,0x7F,0x7F,0x7F,0x0C,0x0C,0x00,0x00,0x00},  // 0x06
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x07
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x08
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x09
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x0A
    {0x00,0x06,0x03,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00},  // 0x0B
    {0x00,0x3C,0x42,0x42,0x42,0x3C,0x08,0x1C,0x08,0x00,0x00,0x00},  // 0x0C
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x0D
    {0x00,0x02,0x0E,0x1A,0x12,0x12,0x12,0x1E,0x1C,0x70,0x60,0x00},  // 0x0E
    {0x00,0x00,0x08,0x3E,0x22,0x63,0x22,0x3E,0x08,0x00,0x00,0x00},  // 0x0F
    {0x00,0x00,0x40,0x70,0x7C,0x7F,0x7C,0x70,0x40,0x00,0x00,0x00},  // 0x10
    {0x00,0x00,0x01,0x07,0x1F,0x7F,0x1F,0x07,0x01,0x00,0x00,0x00},  // 0x11
    {0x00,0x08,0x08,0x1C,0x08,0x08,0x08,0x08,0x08,0x1C,0x08,0x00},  // 0x12
    {0x00,0x24,0x24,0x24,0x24,0x24,0x24,0x00,0x24,0x00,0x00,0x00},  // 0x13
    {0x00,0x3E,0x3A,0x3A,0x1A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x00},  // 0x14
    {0x00,0x1E,0x20,0x30,0x1C,0x22,0x32,0x1C,0x02,0x02,0x3C,0x00},  // 0x15
    {0x00,0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x16
    {0x08,0x08,0x1C,0x08,0x08,0x08,0x08,0x1C,0x08,0x00,0x1C,0x00},  // 0x17
    {0x00,0x08,0x08,0x1C,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00},  // 0x18
    {0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x1C,0x08,0x00},  // 0x19
    {0x00,0x00,0x00,0x00,0x08,0x3E,0x08,0x00,0x00,0x00,0x00,0x00},  // 0x1A
    {0x00,0x00,0x00,0x00,0x10,0x3E,0x10,0x00,0x00,0x00,0x00,0x00},  // 0x1B
    {0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x3E,0x00,0x00,0x00},  // 0x1C
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x1D
    {0x00,0x00,0x08,0x08,0x1C,0x1C,0x3E,0x3E,0x7F,0x00,0x00,0x00},  // 0x1E
    {0x00,0x00,0x7F,0x3E,0x3E,0x1C,0x1C,0x08,0x08,0x00,0x00,0x00},  // 0x1F
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x20
    {0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x08,0x00,0x00,0x00},  // 0x21
    {0x24,0x24,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x22
    {0x00,0x0A,0x0A,0x3F,0x14,0x14,0x7E,0x28,0x28,0x00,0x00,0x00},  // 0x23
    {0x08,0x1E,0x28,0x28,0x18,0x0C,0x0A,0x0A,0x3C,0x08,0x00,0x00},  // 0x24
    {0x00,0x31,0x4A,0x4C,0x38,0x0E,0x19,0x29,0x46,0x00,0x00,0x00},  // 0x25
    {0x00,0x0E,0x12,0x16,0x18,0x69,0x45,0x66,0x3F,0x00,0x00,0x00},  // 0x26
    {0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x27
    {0x06,0x0C,0x08,0x10,0x10,0x10,0x10,0x10,0x08,0x0C,0x06,0x00},  // 0x28
    {0x20,0x18,0x08,0x04,0x04,0x04,0x04,0x04,0x08,0x18,0x30,0x00},  // 0x29
    {0x00,0x08,0x36,0x18,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x2A
    {0x00,0x00,0x00,0x08,0x08,0x7F,0x08,0x08,0x08,0x00,0x00,0x00},  // 0x2B
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x08,0x10,0x00},  // 0x2C
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x2D
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00},  // 0x2E
    {0x01,0x02,0x02,0x04,0x04,0x08,0x10,0x10,0x20,0x20,0x40,0x00},  // 0x2F
    {0x00,0x3C,0x24,0x42,0x42,0x42,0x42,0x24,0x3C,0x00,0x00,0x00},  // 0x30
    {0x00,0x08,0x38,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00},  // 0x31
    {0x00,0x3C,0x02,0x02,0x06,0x08,0x10,0x20,0x3E,0x00,0x00,0x00},  // 0x32
    {0x00,0x3C,0x04,0x04,0x18,0x04,0x04,0x04,0x38,0x00,0x00,0x00},  // 0x33
    {0x00,0x04,0x0C,0x14,0x24,0x44,0x7E,0x04,0x04,0x00,0x00,0x00},  // 0x34
    {0x00,0x3C,0x20,0x20,0x38,0x04,0x04,0x04,0x38,0x00,0x00,0x00},  // 0x35
    {0x00,0x0E,0x10,0x20,0x2C,0x32,0x22,0x22,0x1C,0x00,0x00,0x00},  // 0x36
    {0x00,0x3E,0x02,0x04,0x08,0x10,0x10,0x20,0x20,0x00,0x00,0x00},  // 0x37
    {0x00,0x1C,0x22,0x22,0x1C,0x24,0x22,0x22,0x1C,0x00,0x00,0x00},  // 0x38
    {0x00,0x1C,0x22,0x22,0x22,0x1E,0x02,0x04,0x38,0x00,0x00,0x00},  // 0x39
    {0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00},  // 0x3A
    {0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x08,0x10,0x00},  // 0x3B
    {0x00,0x00,0x00,0x02,0x0C,0x10,0x10,0x0C,0x02,0x00,0x00,0x00},  // 0x3C
    {0x00,0x00,0x00,0x00,0x3E,0x00,0x3E,0x00,0x00,0x00,0x00,0x00},  // 0x3D
    {0x00,0x00,0x00,0x20,0x18,0x04,0x04,0x18,0x20,0x00,0x00,0x00},  // 0x3E
    {0x00,0x3C,0x22,0x02,0x04,0x08,0x08,0x00,0x08,0x00,0x00,0x00},  // 0x3F
    {0x00,0x1C,0x22,0x4E,0x52,0x56,0x5B,0x20,0x1C,0x00,0x00,0x00},  // 0x40
    {0x00,0x08,0x14,0x14,0x14,0x22,0x3E,0x22,0x41,0x00,0x00,0x00},  // 0x41
    {0x00,0x3C,0x22,0x22,0x3C,0x22,0x22,0x22,0x3C,0x00,0x00,0x00},  // 0x42
    {0x00,0x1E,0x20,0x40,0x40,0x40,0x40,0x20,0x1E,0x00,0x00,0x00},  // 0x43
    {0x00,0x78,0x44,0x42,0x42,0x42,0x42,0x44,0x78,0x00,0x00,0x00},  // 0x44
    {0x00,0x3E,0x20,0x20,0x20,0x3C,0x20,0x20,0x3E,0x00,0x00,0x00},  // 0x45
    {0x00,0x3E,0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x00,0x00,0x00},  // 0x46
    {0x00,0x1E,0x20,0x40,0x40,0x4E,0x42,0x22,0x1E,0x00,0x00,0x00},  // 0x47
    {0x00,0x22,0x22,0x22,0x3E,0x22,0x22,0x22,0x22,0x00,0x00,0x00},  // 0x48
    {0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00},  // 0x49
    {0x00,0x3C,0x04,0x04,0x04,0x04,0x04,0x04,0x78,0x00,0x00,0x00},  // 0x4A
    {0x00,0x22,0x24,0x28,0x30,0x30,0x28,0x24,0x22,0x00,0x00,0x00},  // 0x4B
    {0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3E,0x00,0x00,0x00},  // 0x4C
    {0x00,0x66,0x66,0x6A,0x5A,0x5A,0x52,0x42,0x42,0x00,0x00,0x00},  // 0x4D
    {0x00,0x22,0x32,0x32,0x2A,0x2A,0x26,0x26,0x22,0x00,0x00,0x00},  // 0x4E
    {0x00,0x3C,0x24,0x42,0x42,0x42,0x42,0x24,0x3C,0x00,0x00,0x00},  // 0x4F
    {0x00,0x3C,0x22,0x22,0x22,0x3C,0x20,0x20,0x20,0x00,0x00,0x00},  // 0x50
    {0x00,0x3C,0x24,0x42,0x42,0x42,0x42,0x24,0x1C,0x04,0x03,0x00},  // 0x51
    {0x00,0x3C,0x22,0x22,0x24,0x38,0x28,0x24,0x22,0x00,0x00,0x00},  // 0x52
    {0x00,0x1E,0x20,0x20,0x18,0x04,0x02,0x02,0x3C,0x00,0x00,0x00},  // 0x53
    {0x00,0x7F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0x54
    {0x00,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,0x00,0x00},  // 0x55
    {0x00,0x41,0x22,0x22,0x22,0x14,0x14,0x1C,0x08,0x00,0x00,0x00},  // 0x56
    {0x00,0x41,0x41,0x49,0x49,0x35,0x36,0x36,0x22,0x00,0x00,0x00},  // 0x57
    {0x00,0x41,0x22,0x14,0x08,0x08,0x14,0x22,0x41,0x00,0x00,0x00},  // 0x58
    {0x00,0x41,0x22,0x14,0x14,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0x59
    {0x00,0x7E,0x02,0x04,0x08,0x10,0x20,0x40,0x7E,0x00,0x00,0x00},  // 0x5A
    {0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0x00},  // 0x5B
    {0x40,0x20,0x20,0x10,0x10,0x08,0x04,0x04,0x02,0x02,0x01,0x00},  // 0x5C
    {0x3C,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x3C,0x00},  // 0x5D
    {0x08,0x08,0x18,0x14,0x14,0x24,0x22,0x00,0x00,0x00,0x00,0x00},  // 0x5E
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00},  // 0x5F
    {0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0x60
    {0x00,0x00,0x00,0x1C,0x02,0x1E,0x22,0x22,0x1F,0x00,0x00,0x00},  // 0x61
    {0x20,0x20,0x20,0x2C,0x32,0x22,0x22,0x22,0x3C,0x00,0x00,0x00},  // 0x62
    {0x00,0x00,0x00,0x1E,0x20,0x20,0x20,0x20,0x1E,0x00,0x00,0x00},  // 0x63
    {0x02,0x02,0x02,0x1E,0x22,0x22,0x22,0x26,0x1A,0x00,0x00,0x00},  // 0x64
    {0x00,0x00,0x00,0x1C,0x22,0x3E,0x20,0x20,0x1E,0x00,0x00,0x00},  // 0x65
    {0x0E,0x10,0x10,0x7E,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00},  // 0x66
    {0x00,0x00,0x00,0x1E,0x22,0x22,0x22,0x22,0x1E,0x02,0x1C,0x00},  // 0x67
    {0x20,0x20,0x20,0x2E,0x32,0x22,0x22,0x22,0x22,0x00,0x00,0x00},  // 0x68
    {0x08,0x00,0x00,0x38,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0x69
    {0x04,0x00,0x00,0x3C,0x04,0x04,0x04,0x04,0x04,0x04,0x38,0x00},  // 0x6A
    {0x20,0x20,0x20,0x22,0x24,0x38,0x28,0x24,0x22,0x00,0x00,0x00},  // 0x6B
    {0x38,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0x6C
    {0x00,0x00,0x00,0x5B,0x6D,0x49,0x49,0x49,0x49,0x00,0x00,0x00},  // 0x6D
    {0x00,0x00,0x00,0x2E,0x32,0x22,0x22,0x22,0x22,0x00,0x00,0x00},  // 0x6E
    {0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00},  // 0x6F
    {0x00,0x00,0x00,0x2C,0x32,0x22,0x22,0x22,0x3C,0x20,0x20,0x00},  // 0x70
    {0x00,0x00,0x00,0x1E,0x22,0x22,0x22,0x22,0x1E,0x02,0x02,0x00},  // 0x71
    {0x00,0x00,0x00,0x2E,0x32,0x20,0x20,0x20,0x20,0x00,0x00,0x00},  // 0x72
    {0x00,0x00,0x00,0x1E,0x20,0x38,0x06,0x02,0x3C,0x00,0x00,0x00},  // 0x73
    {0x00,0x10,0x10,0x7E,0x10,0x10,0x10,0x10,0x0E,0x00,0x00,0x00},  // 0x74
    {0x00,0x00,0x00,0x22,0x22,0x22,0x22,0x26,0x3A,0x00,0x00,0x00},  // 0x75
    {0x00,0x00,0x00,0x41,0x22,0x22,0x14,0x14,0x08,0x00,0x00,0x00},  // 0x76
    {0x00,0x00,0x00,0x41,0x49,0x55,0x55,0x36,0x22,0x00,0x00,0x00},  // 0x77
    {0x00,0x00,0x00,0x42,0x24,0x18,0x18,0x24,0x42,0x00,0x00,0x00},  // 0x78
    {0x00,0x00,0x00,0x42,0x24,0x24,0x18,0x18,0x10,0x10,0x60,0x00},  // 0x79
    {0x00,0x00,0x00,0x7E,0x04,0x08,0x10,0x20,0x7E,0x00,0x00,0x00},  // 0x7A
    {0x0E,0x08,0x08,0x08,0x08,0x30,0x08,0x08,0x08,0x08,0x06,0x00},  // 0x7B
    {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00},  // 0x7C
    {0x30,0x08,0x08,0x08,0x08,0x06,0x08,0x08,0x08,0x08,0x38,0x00},  // 0x7D
    {0x00,0x00,0x00,0x00,0x00,0x39,0x4E,0x00,0x00,0x00,0x00,0x00},  // 0x7E
    {0x00,0x00,0x08,0x14,0x36,0x22,0x22,0x22,0x3E,0x00,0x00,0x00},  // 0x7F
    {0x00,0x1E,0x20,0x40,0x40,0x40,0x40,0x20,0x1E,0x04,0x02,0x06},  // 0x80
    {0x00,0x14,0x00,0x22,0x22,0x22,0x22,0x26,0x3A,0x00,0x00,0x00},  // 0x81
    {0x04,0x08,0x00,0x1C,0x22,0x3E,0x20,0x20,0x1E,0x00,0x00,0x00},  // 0x82
    {0x0C,0x12,0x00,0x1C,0x02,0x1E,0x22,0x22,0x1F,0x00,0x00,0x00},  // 0x83
    {0x00,0x14,0x00,0x1C,0x02,0x1E,0x22,0x22,0x1F,0x00,0x00,0x00},  // 0x84
    {0x10,0x08,0x00,0x1C,0x02,0x1E,0x22,0x22,0x1F,0x00,0x00,0x00},  // 0x85
    {0x08,0x14,0x08,0x1C,0x02,0x1E,0x22,0x22,0x1F,0x00,0x00,0x00},  // 0x86
    {0x00,0x00,0x00,0x1E,0x20,0x20,0x20,0x20,0x1E,0x08,0x04,0x0C},  // 0x87
    {0x0C,0x12,0x00,0x1C,0x22,0x3E,0x20,0x20,0x1E,0x00,0x00,0x00},  // 0x88
    {0x00,0x14,0x00,0x1C,0x22,0x3E,0x20,0x20,0x1E,0x00,0x00,0x00},  // 0x89
    {0x10,0x08,0x00,0x1C,0x22,0x3E,0x20,0x20,0x1E,0x00,0x00,0x00},  // 0x8A
    {0x00,0x14,0x00,0x38,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0x8B
    {0x0C,0x12,0x00,0x38,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0x8C
    {0x10,0x08,0x00,0x38,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0x8D
    {0x24,0x08,0x14,0x14,0x14,0x22,0x3E,0x22,0x41,0x00,0x00,0x00},  // 0x8E
    {0x1C,0x08,0x14,0x14,0x14,0x22,0x3E,0x22,0x41,0x00,0x00,0x00},  // 0x8F
    {0x04,0x3E,0x20,0x20,0x20,0x3C,0x20,0x20,0x3E,0x00,0x00,0x00},  // 0x90
    {0x00,0x00,0x00,0x76,0x09,0x3F,0x48,0x48,0x37,0x00,0x00,0x00},  // 0x91
    {0x00,0x0F,0x0C,0x14,0x14,0x26,0x3C,0x24,0x47,0x00,0x00,0x00},  // 0x92
    {0x0C,0x12,0x00,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00},  // 0x93
    {0x00,0x14,0x00,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00},  // 0x94
    {0x10,0x08,0x00,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00},  // 0x95
    {0x0C,0x12,0x00,0x22,0x22,0x22,0x22,0x26,0x3A,0x00,0x00,0x00},  // 0x96
    {0x20,0x10,0x00,0x22,0x22,0x22,0x22,0x26,0x3A,0x00,0x00,0x00},  // 0x97
    {0x00,0x14,0x00,0x42,0x24,0x24,0x18,0x18,0x10,0x10,0x60,0x00},  // 0x98
    {0x24,0x3C,0x24,0x42,0x42,0x42,0x42,0x24,0x3C,0x00,0x00,0x00},  // 0x99
    {0x24,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,0x00,0x00},  // 0x9A
    {0x00,0x00,0x00,0x3E,0x46,0x4A,0x52,0x62,0x7C,0x00,0x00,0x00},  // 0x9B
    {0x00,0x06,0x08,0x08,0x1C,0x08,0x08,0x10,0x1E,0x00,0x00,0x00},  // 0x9C
    {0x00,0x3E,0x24,0x46,0x4A,0x52,0x62,0x24,0x7C,0x00,0x00,0x00},  // 0x9D
    {0x00,0x00,0x00,0x42,0x24,0x18,0x18,0x24,0x42,0x00,0x00,0x00},  // 0x9E
    {0x07,0x08,0x08,0x1E,0x08,0x08,0x08,0x08,0x08,0x08,0x70,0x00},  // 0x9F
    {0x04,0x08,0x00,0x1C,0x02,0x1E,0x22,0x22,0x1F,0x00,0x00,0x00},  // 0xA0
    {0x04,0x08,0x00,0x38,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0xA1
    {0x04,0x08,0x00,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00},  // 0xA2
    {0x04,0x08,0x00,0x22,0x22,0x22,0x22,0x26,0x3A,0x00,0x00,0x00},  // 0xA3
    {0x0A,0x14,0x00,0x2E,0x32,0x22,0x22,0x22,0x22,0x00,0x00,0x00},  // 0xA4
    {0x0A,0x36,0x32,0x32,0x2A,0x2A,0x26,0x26,0x22,0x00,0x00,0x00},  // 0xA5
    {0x00,0x3C,0x04,0x1C,0x24,0x3E,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xA6
    {0x00,0x1C,0x22,0x22,0x22,0x1C,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xA7
    {0x00,0x00,0x00,0x08,0x00,0x08,0x08,0x10,0x20,0x22,0x1E,0x00},  // 0xA8
    {0x00,0x3C,0x42,0x5A,0x5A,0x42,0x3C,0x00,0x00,0x00,0x00,0x00},  // 0xA9
    {0x00,0x00,0x00,0x00,0x7E,0x02,0x02,0x00,0x00,0x00,0x00,0x00},  // 0xAA
    {0x00,0x62,0x24,0x28,0x2F,0x11,0x12,0x24,0x47,0x00,0x00,0x00},  // 0xAB
    {0x00,0x62,0x24,0x28,0x2A,0x16,0x1A,0x2F,0x42,0x00,0x00,0x00},  // 0xAC
    {0x00,0x00,0x00,0x08,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x00},  // 0xAD
    {0x00,0x00,0x00,0x0A,0x14,0x28,0x14,0x0A,0x00,0x00,0x00,0x00},  // 0xAE
    {0x00,0x00,0x00,0x28,0x14,0x0A,0x14,0x28,0x00,0x00,0x00,0x00},  // 0xAF
    {0x52,0x00,0x52,0x00,0x00,0x52,0x00,0x52,0x00,0x00,0x52,0x00},  // 0xB0
    {0x25,0x52,0x25,0x00,0x52,0x25,0x52,0x25,0x52,0x00,0x25,0x52},  // 0xB1
    {0x7F,0x52,0x7F,0x52,0x52,0x7F,0x52,0x7F,0x52,0x52,0x7F,0x52},  // 0xB2
    {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},  // 0xB3
    {0x08,0x08,0x08,0x08,0x08,0x78,0x08,0x08,0x08,0x08,0x08,0x08},  // 0xB4
    {0x08,0x18,0x14,0x14,0x14,0x22,0x3E,0x22,0x41,0x00,0x00,0x00},  // 0xB5
    {0x18,0x2C,0x14,0x14,0x14,0x22,0x3E,0x22,0x41,0x00,0x00,0x00},  // 0xB6
    {0x20,0x18,0x14,0x14,0x14,0x22,0x3E,0x22,0x41,0x00,0x00,0x00},  // 0xB7
    {0x00,0x1C,0x22,0x4D,0x51,0x51,0x4D,0x22,0x1C,0x00,0x00,0x00},  // 0xB8
    {0x14,0x14,0x14,0x14,0x74,0x04,0x74,0x14,0x14,0x14,0x14,0x14},  // 0xB9
    {0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14},  // 0xBA
    {0x00,0x00,0x00,0x00,0x7C,0x04,0x74,0x14,0x14,0x14,0x14,0x14},  // 0xBB
    {0x14,0x14,0x14,0x14,0x74,0x04,0x7C,0x00,0x00,0x00,0x00,0x00},  // 0xBC
    {0x00,0x04,0x1E,0x34,0x24,0x24,0x34,0x1E,0x04,0x00,0x00,0x00},  // 0xBD
    {0x00,0x41,0x22,0x14,0x08,0x3E,0x08,0x3E,0x08,0x00,0x00,0x00},  // 0xBE
    {0x00,0x00,0x00,0x00,0x00,0x78,0x08,0x08,0x08,0x08,0x08,0x08},  // 0xBF
    {0x08,0x08,0x08,0x08,0x08,0x0F,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xC0
    {0x08,0x08,0x08,0x08,0x08,0x7F,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xC1
    {0x00,0x00,0x00,0x00,0x00,0x7F,0x08,0x08,0x08,0x08,0x08,0x08},  // 0xC2
    {0x08,0x08,0x08,0x08,0x08,0x0F,0x08,0x08,0x08,0x08,0x08,0x08},  // 0xC3
    {0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xC4
    {0x08,0x08,0x08,0x08,0x08,0x7F,0x08,0x08,0x08,0x08,0x08,0x08},  // 0xC5
    {0x0A,0x14,0x00,0x1C,0x02,0x1E,0x22,0x22,0x1F,0x00,0x00,0x00},  // 0xC6
    {0x0A,0x1C,0x14,0x14,0x14,0x22,0x3E,0x22,0x41,0x00,0x00,0x00},  // 0xC7
    {0x14,0x14,0x14,0x14,0x17,0x10,0x1F,0x00,0x00,0x00,0x00,0x00},  // 0xC8
    {0x00,0x00,0x00,0x00,0x1F,0x10,0x17,0x14,0x14,0x14,0x14,0x14},  // 0xC9
    {0x14,0x14,0x14,0x14,0x77,0x00,0x7F,0x00,0x00,0x00,0x00,0x00},  // 0xCA
    {0x00,0x00,0x00,0x00,0x7F,0x00,0x77,0x14,0x14,0x14,0x14,0x14},  // 0xCB
    {0x14,0x14,0x14,0x14,0x17,0x10,0x17,0x14,0x14,0x14,0x14,0x14},  // 0xCC
    {0x00,0x00,0x00,0x00,0x7F,0x00,0x7F,0x00,0x00,0x00,0x00,0x00},  // 0xCD
    {0x14,0x14,0x14,0x14,0x77,0x00,0x77,0x14,0x14,0x14,0x14,0x14},  // 0xCE
    {0x00,0x41,0x3E,0x22,0x22,0x22,0x3E,0x41,0x00,0x00,0x00,0x00},  // 0xCF
    {0x68,0x18,0x2C,0x3E,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00},  // 0xD0
    {0x00,0x78,0x44,0x42,0x62,0x42,0x42,0x44,0x78,0x00,0x00,0x00},  // 0xD1
    {0x18,0x3E,0x20,0x20,0x20,0x3C,0x20,0x20,0x3E,0x00,0x00,0x00},  // 0xD2
    {0x24,0x3E,0x20,0x20,0x20,0x3C,0x20,0x20,0x3E,0x00,0x00,0x00},  // 0xD3
    {0x10,0x3E,0x20,0x20,0x20,0x3C,0x20,0x20,0x3E,0x00,0x00,0x00},  // 0xD4
    {0x00,0x00,0x00,0x38,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0xD5
    {0x04,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00},  // 0xD6
    {0x18,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00},  // 0xD7
    {0x24,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00},  // 0xD8
    {0x08,0x08,0x08,0x08,0x08,0x78,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xD9
    {0x00,0x00,0x00,0x00,0x00,0x0F,0x08,0x08,0x08,0x08,0x08,0x08},  // 0xDA
    {0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F},  // 0xDB
    {0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F},  // 0xDC
    {0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x00},  // 0xDD
    {0x10,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00},  // 0xDE
    {0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xDF
    {0x04,0x3C,0x24,0x42,0x42,0x42,0x42,0x24,0x3C,0x00,0x00,0x00},  // 0xE0
    {0x3C,0x24,0x24,0x28,0x28,0x24,0x22,0x21,0x2E,0x00,0x00,0x00},  // 0xE1
    {0x18,0x3C,0x24,0x42,0x42,0x42,0x42,0x24,0x3C,0x00,0x00,0x00},  // 0xE2
    {0x10,0x3C,0x24,0x42,0x42,0x42,0x42,0x24,0x3C,0x00,0x00,0x00},  // 0xE3
    {0x0A,0x14,0x00,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00},  // 0xE4
    {0x0A,0x3C,0x24,0x42,0x42,0x42,0x42,0x24,0x3C,0x00,0x00,0x00},  // 0xE5
    {0x00,0x00,0x00,0x22,0x22,0x22,0x22,0x26,0x3A,0x20,0x20,0x00},  // 0xE6
    {0x20,0x20,0x20,0x2C,0x32,0x22,0x22,0x22,0x3C,0x20,0x20,0x00},  // 0xE7
    {0x00,0x20,0x3C,0x22,0x22,0x22,0x22,0x3C,0x20,0x00,0x00,0x00},  // 0xE8
    {0x04,0x2A,0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,0x00,0x00},  // 0xE9
    {0x18,0x26,0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,0x00,0x00},  // 0xEA
    {0x10,0x2A,0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,0x00,0x00},  // 0xEB
    {0x04,0x08,0x00,0x42,0x24,0x24,0x18,0x18,0x10,0x10,0x60,0x00},  // 0xEC
    {0x04,0x49,0x22,0x14,0x14,0x08,0x08,0x08,0x08,0x00,0x00,0x00},  // 0xED
    {0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xEE
    {0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xEF
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xF0
    {0x00,0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x3E,0x00,0x00,0x00},  // 0xF1
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x7F},  // 0xF2
    {0x00,0x71,0x72,0x14,0x7A,0x0E,0x1A,0x2F,0x42,0x00,0x00,0x00},  // 0xF3
    {0x00,0x3E,0x3A,0x3A,0x1A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x00},  // 0xF4
    {0x00,0x1E,0x20,0x30,0x1C,0x22,0x32,0x1C,0x02,0x02,0x3C,0x00},  // 0xF5
    {0x00,0x00,0x00,0x10,0x00,0x7E,0x00,0x00,0x10,0x00,0x00,0x00},  // 0xF6
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x04,0x0C},  // 0xF7
    {0x00,0x08,0x14,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xF8
    {0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xF9
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},  // 0xFA
    {0x00,0x18,0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xFB
    {0x00,0x1E,0x0E,0x02,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xFC
    {0x00,0x1E,0x02,0x0C,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // 0xFD
    {0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00},  // 0xFE
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}   // 0xFF
};
#endif

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * refresh status LED
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_refresh_status_led (void)
{
    led_refresh (DSP_STATUS_LEDS);
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * refresh minute LEDs
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
#if DSP_MINUTE_LEDS != 0
static void
display_refresh_minute_leds (void)
{
    led_refresh (DSP_STATUS_LEDS + DSP_MINUTE_LEDS);
}
#endif

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * refresh display LEDs
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_refresh_display_leds (void)
{
    led_refresh (DSP_STATUS_LEDS + DSP_MINUTE_LEDS + DSP_DISPLAY_LEDS);
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * refresh ambilight LEDs
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_refresh_ambilight_leds (void)
{
    led_refresh (DSP_STATUS_LEDS + DSP_MINUTE_LEDS + DSP_DISPLAY_LEDS + DSP_AMBILIGHT_LEDS);
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * set status LED
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_set_status_led (uint_fast8_t r_flag, uint_fast8_t g_flag, uint_fast8_t b_flag)
{
    if (DSP_STATUS_LEDS > 0)
    {
        LED_RGB rgb;

        rgb.red     = r_flag ? pwmtable8[MAX_COLOR_STEPS - 1] : 0;
        rgb.green   = g_flag ? pwmtable8[MAX_COLOR_STEPS - 1] : 0;
        rgb.blue    = b_flag ? pwmtable8[MAX_COLOR_STEPS - 1] : 0;

        led_set_led (DSP_STATUS_LED_OFFSET, &rgb);
        display_refresh_status_led ();
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * display minute LEDs
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
#if DSP_MINUTE_LEDS != 0
static void
display_minute_leds (uint_fast8_t power_is_on, uint_fast8_t minute)
{
    LED_RGB         rgb;
    LED_RGB         rgb0;
    uint_fast8_t    n_leds;
    uint_fast8_t    i;

    if (DSP_MINUTE_LEDS > 0)
    {
        rgb0.red        = 0;
        rgb0.green      = 0;
        rgb0.blue       = 0;

        if (power_is_on)
        {
            rgb.red         = pwmtable8[dimmed_colors.red];
            rgb.green       = pwmtable8[dimmed_colors.green];
            rgb.blue        = pwmtable8[dimmed_colors.blue];

            n_leds = minute % 5;

            for (i = 0; i < DSP_MINUTE_LEDS; i++)
            {
                if (i < n_leds)
                {
                    led_set_led (DSP_MINUTE_LED_OFFSET + i, &rgb);
                }
                else
                {
                    led_set_led (DSP_MINUTE_LED_OFFSET + i, &rgb0);
                }
            }
        }
        else
        {
            for (i = 0; i < DSP_MINUTE_LEDS; i++)
            {
                led_set_led (DSP_MINUTE_LED_OFFSET + i, &rgb0);
            }
        }

        display_refresh_minute_leds ();
    }
}
#endif

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * set display LED to RGB
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_set_display_led (uint_fast16_t n, LED_RGB * rgb, uint_fast8_t refresh)
{
	if (n < DSP_DISPLAY_LEDS)
	{
        uint_fast8_t y;
        uint_fast8_t x;

        y = n / WC_COLUMNS;

        if (y & 0x01)                                       // snake: odd row: count from right to left
        {
            x = n % WC_COLUMNS;
            n = y * WC_COLUMNS + (WC_COLUMNS - 1 - x);
        }

        led_set_led (DSP_DISPLAY_LED_OFFSET + n, rgb);

        if (refresh)
        {
            display_refresh_display_leds ();
        }
	}
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * set ambilight LEDs to RGB
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_set_ambilight_led (LED_RGB * rgb, uint_fast8_t refresh)
{
    uint_fast16_t   n;

    for (n = 0; n < DSP_AMBILIGHT_LEDS; n++)
    {
        led_set_led (DSP_AMBILIGHT_LED_OFFSET + n, rgb);
    }

    if (refresh)
    {
        display_refresh_ambilight_leds();
	}
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * switch all LEDs off
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_reset_led_states (void)
{
    uint_fast16_t     idx;

    for (idx = 0; idx < DSP_DISPLAY_LEDS; idx++)
    {
        if (led.state[idx] & TARGET_STATE)
        {
            led.state[idx] = CURRENT_STATE;
        }
        else
        {
            led.state[idx] = 0;
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * display one LED
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_led_on (uint_fast8_t y, uint_fast8_t x)
{
    led.matrix[y][x] |= TARGET_STATE;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * display one word
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_word_on (uint_fast8_t idx)
{
#if WCLOCK24H == 1
    uint_fast8_t y = illumination[0][idx].row;
    uint_fast8_t x = illumination[0][idx].col;
    uint_fast8_t l = illumination[0][idx].len;
#else
    uint_fast8_t y = illumination[idx].row;
    uint_fast8_t x = illumination[idx].col;
    uint_fast8_t l = illumination[idx].len;
#endif

    while (l--)
    {
        display_led_on (y, x);
        x++;
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * flush animation
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_flush (uint_fast8_t flush_ambi)
{
    static uint_fast8_t already_called;
    LED_RGB          rgb;
    LED_RGB          rgb0;
    uint_fast16_t       idx;

    if (! already_called)
    {
        flush_ambi = 1;
        already_called = 1;
    }

    rgb.red         = pwmtable8[dimmed_colors.red];
    rgb.green       = pwmtable8[dimmed_colors.green];
    rgb.blue        = pwmtable8[dimmed_colors.blue];

    rgb0.red        = 0;
    rgb0.green      = 0;
    rgb0.blue       = 0;

    for (idx = 0; idx < DSP_DISPLAY_LEDS; idx++)
    {
        if (led.state[idx] & TARGET_STATE)                          // fm: == ???
        {
            display_set_display_led (idx, &rgb, 0);
            led.state[idx] |= CURRENT_STATE;                        // we are in sync
        }
        else
        {
            display_set_display_led (idx, &rgb0, 0);
            led.state[idx] &= ~CURRENT_STATE;                       // we are in sync
        }
    }

    if (flush_ambi)
    {
        display_set_ambilight_led (&rgb, 0);
        display_refresh_ambilight_leds ();
    }
    else
    {
        display_refresh_display_leds ();
    }

    animation_stop_flag = 1;
}

static void
display_animation_none (void)
{
    if (animation_start_flag)
    {
        animation_start_flag = 0;
        animation_stop_flag = 0;
        display_animation_flush (FALSE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * fade
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_fade (void)
{
    uint_fast16_t    idx;
    uint_fast8_t     changed = 0;

    if (animation_start_flag)
    {
        animation_start_flag = 0;
        animation_stop_flag = 0;

        red_step = dimmed_colors.red / 5;

        if (red_step == 0 && dimmed_colors.red > 0)
        {
            red_step = 1;
        }

        green_step = dimmed_colors.green / 5;

        if (green_step == 0 && dimmed_colors.green > 0)
        {
            green_step = 1;
        }

        blue_step = dimmed_colors.blue / 5;

        if (blue_step == 0 && dimmed_colors.blue > 0)
        {
            blue_step = 1;
        }

        dimmed_colors_up.red       = 0;
        dimmed_colors_up.green     = 0;
        dimmed_colors_up.blue      = 0;

        dimmed_colors_down.red     = dimmed_colors.red;
        dimmed_colors_down.green   = dimmed_colors.green;
        dimmed_colors_down.blue    = dimmed_colors.blue;
    }

    if (! animation_stop_flag)
    {
        if (red_step > 0)
        {
            if (dimmed_colors_down.red >= red_step)
            {
                dimmed_colors_down.red -= red_step;
                changed = 1;
            }
            else if (dimmed_colors_down.red != 0)
            {
                dimmed_colors_down.red = 0;
                changed = 1;
            }

            if (dimmed_colors_up.red + red_step <= dimmed_colors.red)
            {
                dimmed_colors_up.red += red_step;
                changed = 1;
            }
            else if (dimmed_colors_up.red != dimmed_colors.red)
            {
                dimmed_colors_up.red = dimmed_colors.red;
                changed = 1;
            }
        }

        if (green_step > 0)
        {
            if (dimmed_colors_down.green >= green_step)
            {
                dimmed_colors_down.green -= green_step;
                changed = 1;
            }
            else if (dimmed_colors_down.green != 0)
            {
                dimmed_colors_down.green = 0;
                changed = 1;
            }

            if (dimmed_colors_up.green + green_step <= dimmed_colors.green)
            {
                dimmed_colors_up.green += green_step;
                changed = 1;
            }
            else if (dimmed_colors_up.green != dimmed_colors.green)
            {
                dimmed_colors_up.green = dimmed_colors.green;
                changed = 1;
            }
        }

        if (blue_step > 0)
        {
            if (dimmed_colors_down.blue >= blue_step)
            {
                dimmed_colors_down.blue -= blue_step;
                changed = 1;
            }
            else if (dimmed_colors_down.blue != 0)
            {
                dimmed_colors_down.blue = 0;
                changed = 1;
            }

            if (dimmed_colors_up.blue + blue_step <= dimmed_colors.blue)
            {
                dimmed_colors_up.blue += blue_step;
                changed = 1;
            }
            else if (dimmed_colors_up.blue != dimmed_colors.blue)
            {
                dimmed_colors_up.blue = dimmed_colors.blue;
                changed = 1;
            }
        }

        if (changed)
        {
            LED_RGB  rgb;
            LED_RGB  rgb_up;
            LED_RGB  rgb_down;

            rgb.red         = pwmtable8[dimmed_colors.red];
            rgb.green       = pwmtable8[dimmed_colors.green];
            rgb.blue        = pwmtable8[dimmed_colors.blue];

            rgb_up.red      = pwmtable8[dimmed_colors_up.red];
            rgb_up.green    = pwmtable8[dimmed_colors_up.green];
            rgb_up.blue     = pwmtable8[dimmed_colors_up.blue];

            rgb_down.red    = pwmtable8[dimmed_colors_down.red];
            rgb_down.green  = pwmtable8[dimmed_colors_down.green];
            rgb_down.blue   = pwmtable8[dimmed_colors_down.blue];

            for (idx = 0; idx < DSP_DISPLAY_LEDS; idx++)
            {
                if (led.state[idx] == TARGET_STATE)                           // up
                {
                    display_set_display_led (idx, &rgb_up, 0);
                }
                else if (led.state[idx] == CURRENT_STATE)                     // down
                {
                    display_set_display_led (idx, &rgb_down, 0);
                }
                else if (led.state[idx] == (CURRENT_STATE | TARGET_STATE))    // on, but no change
                {
                    display_set_display_led (idx, &rgb, 0);
                }
            }

            display_refresh_display_leds ();
        }
        else
        {
            animation_stop_flag = 1;
        }
    }
}

static void
display_show_new_display (void)
{
    LED_RGB          rgb;
    LED_RGB          rgb0;
    uint_fast16_t       idx;

    rgb.red         = pwmtable8[dimmed_colors.red];
    rgb.green       = pwmtable8[dimmed_colors.green];
    rgb.blue        = pwmtable8[dimmed_colors.blue];

    rgb0.red        = 0;
    rgb0.green      = 0;
    rgb0.blue       = 0;

    for (idx = 0; idx < DSP_DISPLAY_LEDS; idx++)
    {
        if (led.state[idx] & NEW_STATE)                                // on
        {
            display_set_display_led (idx, &rgb, 0);
        }
        else
        {
            display_set_display_led (idx, &rgb0, 0);
        }
    }

    display_refresh_display_leds ();
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * roll right
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_roll_right (void)
{
    static uint_fast16_t    cnt;
    uint_fast16_t           y;
    uint_fast16_t           x;

    if (animation_start_flag)
    {
        animation_start_flag = 0;
        animation_stop_flag = 0;
        cnt = 0;
    }

    if (! animation_stop_flag)
    {
        if (cnt < WC_COLUMNS)
        {
            cnt++;                                                  // 1...WC_COLUMNS

            for (y = 0; y < WC_ROWS * WC_COLUMNS; y += WC_COLUMNS)
            {
                for (x = 0; x < WC_COLUMNS; x++)
                {
                    if (x >= cnt)
                    {
                        if (led.state[y + x - cnt] & CURRENT_STATE)
                        {
                            led.state[y + x] |= NEW_STATE;
                        }
                        else
                        {
                            led.state[y + x] &= ~NEW_STATE;
                        }
                    }
                    else
                    {
                        if (led.state[y + x + WC_COLUMNS - cnt] & TARGET_STATE)
                        {
                            led.state[y + x] |= NEW_STATE;
                        }
                        else
                        {
                            led.state[y + x] &= ~NEW_STATE;
                        }
                    }
                }
            }

            display_show_new_display ();
        }
        else
        {
            animation_stop_flag = 1;
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * roll left
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_roll_left ()
{
    static uint_fast16_t    cnt;
    uint_fast16_t           y;
    uint_fast16_t           x;

    if (animation_start_flag)
    {
        animation_start_flag = 0;
        animation_stop_flag = 0;
        cnt = 0;
    }

    if (! animation_stop_flag)
    {
        if (cnt < WC_COLUMNS)
        {
            cnt++;                                                  // 1...WC_COLUMNS

            for (y = 0; y < WC_ROWS * WC_COLUMNS; y += WC_COLUMNS)
            {
                for (x = 0; x < WC_COLUMNS; x++)
                {
                    if (x + cnt < WC_COLUMNS)
                    {
                        if (led.state[y + x + cnt] & CURRENT_STATE)
                        {
                            led.state[y + x] |= NEW_STATE;
                        }
                        else
                        {
                            led.state[y + x] &= ~NEW_STATE;
                        }
                    }
                    else
                    {
                        if (led.state[y + x + cnt - WC_COLUMNS] & TARGET_STATE)
                        {
                            led.state[y + x] |= NEW_STATE;
                        }
                        else
                        {
                            led.state[y + x] &= ~NEW_STATE;
                        }
                    }
                }
            }

            display_show_new_display ();
        }
        else
        {
            animation_stop_flag = 1;
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * roll down
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_roll_down ()
{
    static uint_fast16_t    cnt;
    uint_fast16_t           y;
    uint_fast16_t           x;

    if (animation_start_flag)
    {
        animation_start_flag = 0;
        animation_stop_flag = 0;
        cnt = 0;
    }

    if (! animation_stop_flag)
    {
        if (cnt < WC_ROWS * WC_COLUMNS)
        {
            cnt += WC_COLUMNS;                                  // (1...WC_ROWS) * WC_COLUMNS

            for (y = 0; y < WC_ROWS * WC_COLUMNS; y += WC_COLUMNS)
            {
                for (x = 0; x < WC_COLUMNS; x++)
                {
                    if (y >= cnt)
                    {
                        if (led.state[y - cnt + x] & CURRENT_STATE)
                        {
                            led.state[y + x] |= NEW_STATE;
                        }
                        else
                        {
                            led.state[y + x] &= ~NEW_STATE;
                        }
                    }
                    else
                    {
                        if (led.state[y + (WC_ROWS * WC_COLUMNS - cnt) + x] & TARGET_STATE)
                        {
                            led.state[y + x] |= NEW_STATE;
                        }
                        else
                        {
                            led.state[y + x] &= ~NEW_STATE;
                        }
                    }
                }
            }
            display_show_new_display ();
        }
        else
        {
            animation_stop_flag = 1;
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * roll up
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_roll_up ()
{
    static uint_fast16_t    cnt;
    uint_fast16_t           y;
    uint_fast16_t           x;

    if (animation_start_flag)
    {
        animation_start_flag = 0;
        animation_stop_flag = 0;
        cnt = 0;
    }

    if (! animation_stop_flag)
    {
        if (cnt < WC_ROWS * WC_COLUMNS)
        {
            cnt += WC_COLUMNS;                                  // (1...WC_ROWS) * WC_COLUMNS

            for (y = 0; y < WC_ROWS * WC_COLUMNS; y += WC_COLUMNS)
            {
                for (x = 0; x < WC_COLUMNS; x++)
                {
                    if (y + cnt < WC_ROWS * WC_COLUMNS)
                    {
                        if (led.state[y + cnt + x] & CURRENT_STATE)
                        {
                            led.state[y + x] |= NEW_STATE;
                        }
                        else
                        {
                            led.state[y + x] &= ~NEW_STATE;
                        }
                    }
                    else
                    {
                        if (led.state[y + (cnt - WC_ROWS * WC_COLUMNS) + x] & TARGET_STATE)
                        {
                            led.state[y + x] |= NEW_STATE;
                        }
                        else
                        {
                            led.state[y + x] &= ~NEW_STATE;
                        }
                    }
                }
            }
            display_show_new_display ();
        }
        else
        {
            animation_stop_flag = 1;
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * roll
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_roll ()
{
    static uint32_t        x;

    if (animation_start_flag)
    {
        x = rand () % 4;
    }

    switch (x)
    {
        case 0:     display_animation_roll_right ();       break;
        case 1:     display_animation_roll_left  ();       break;
        case 2:     display_animation_roll_down  ();       break;
        case 3:     display_animation_roll_up    ();       break;
    }
}

static void
display_animation_calc_implode (int n)
{
    uint_fast8_t    y;
    uint_fast16_t   yi;
    uint_fast8_t    x;
    uint_fast16_t   xi;
    uint_fast8_t    ny;
    uint_fast8_t    nx;

    for (yi = 0; yi < WC_ROWS * WC_COLUMNS; yi += WC_COLUMNS)
    {
        for (xi = 0; xi < WC_COLUMNS; xi++)
        {
            led.state[yi + xi] &= ~CALC_STATE;
        }
    }

    for (y = 0; y < WC_ROWS; y++)
    {
        for (x = 0; x < WC_COLUMNS; x++)
        {
            if (led.matrix[y][x] & TARGET_STATE)
            {
                if (y < WC_ROWS / 2)
                {
                    if (x < WC_COLUMNS / 2)
                    {
                        ny = y + n;
                        nx = x + n;

                        if (ny > WC_ROWS / 2 - 1)
                        {
                            ny = WC_ROWS / 2 - 1;
                        }

                        if (nx > WC_COLUMNS / 2 - 1)
                        {
                            nx = WC_COLUMNS / 2 - 1;
                        }
                    }
                    else
                    {
                        ny = y + n;
                        nx = x - n;

                        if (ny > WC_ROWS / 2 - 1)
                        {
                            ny = WC_ROWS / 2 - 1;
                        }

                        if (nx < WC_COLUMNS / 2)
                        {
                            nx = WC_COLUMNS / 2;
                        }
                    }
                }
                else
                {
                    if (x < WC_COLUMNS / 2)
                    {
                        ny = y - n;
                        nx = x + n;

                        if (ny < WC_ROWS / 2)
                        {
                            ny = WC_ROWS / 2;
                        }

                        if (nx > WC_COLUMNS / 2 - 1)
                        {
                            nx = WC_COLUMNS / 2 - 1;
                        }
                    }
                    else
                    {
                        ny = y - n;
                        nx = x - n;

                        if (ny < WC_ROWS / 2)
                        {
                            ny = WC_ROWS / 2;
                        }

                        if (nx < WC_COLUMNS / 2)
                        {
                            nx = WC_COLUMNS / 2;
                        }
                    }
                }

                led.matrix[ny][nx] |= CALC_STATE;
            }
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * explode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_explode (void)
{
    static uint_fast8_t cnt;
    uint_fast8_t        y;
    uint_fast16_t       yi;
    uint_fast8_t        x;

    if (animation_start_flag)
    {
        animation_start_flag = 0;
        animation_stop_flag = 0;
        cnt = 0;
    }

    if (! animation_stop_flag)
    {
        if (cnt < WC_COLUMNS / 2)
        {
            for (y = 0; y < WC_ROWS; y++)
            {
                for (x = 0; x < WC_COLUMNS; x++)
                {
                    led.matrix[y][x] &= ~NEW_STATE;
                }
            }

            cnt++;

            display_animation_calc_implode (WC_COLUMNS / 2 - cnt);

            for (y = 0, yi = 0; y < WC_ROWS; y++, yi += WC_COLUMNS)
            {
                for (x = 0; x < WC_COLUMNS; x++)
                {
                    if (led.matrix[y][x] & CURRENT_STATE)
                    {
                        if (y < WC_ROWS / 2)
                        {
                            if (x < WC_COLUMNS / 2)
                            {
                                if (y >= cnt && x >= cnt)
                                {
                                    led.matrix[y - cnt][x - cnt] |= NEW_STATE;
                                }
                            }
                            else
                            {
                                if (y >= cnt && x + cnt < WC_COLUMNS)
                                {
                                    led.matrix[y - cnt][x + cnt] |= NEW_STATE;
                                }
                            }
                        }
                        else
                        {
                            if (x < WC_COLUMNS / 2)
                            {
                                if (y + cnt < WC_ROWS && x >= cnt)
                                {
                                    led.matrix[y + cnt][x - cnt] |= NEW_STATE;
                                }
                            }
                            else
                            {
                                if (y + cnt < WC_ROWS && x + cnt < WC_COLUMNS)
                                {
                                    led.matrix[y + cnt][x + cnt] |= NEW_STATE;
                                }
                            }
                        }
                    }

                    if (led.state[yi + x] & CALC_STATE)
                    {
                        led.state[yi + x] |= NEW_STATE;        // matrix leds |= calculated leds
                    }
                }
            }

            display_show_new_display ();
        }
        else
        {
            animation_stop_flag = 1;
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * random animation
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_animation_random ()
{
    static uint32_t x;

    if (animation_start_flag)
    {
        x = rand () % 6;
    }

    switch (x)
    {
        case 0:     display_animation_fade ();          break;
        case 1:     display_animation_roll_right ();    break;
        case 2:     display_animation_roll_left ();     break;
        case 3:     display_animation_roll_down ();     break;
        case 4:     display_animation_roll_up ();       break;
        case 5:     display_animation_explode ();       break;
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * animation
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_animation (void)
{
    switch (animation_mode)
    {
        case ANIMATION_MODE_FADE:       display_animation_fade ();      break;
        case ANIMATION_MODE_ROLL:       display_animation_roll ();      break;
        case ANIMATION_MODE_EXPLODE:    display_animation_explode ();   break;
        case ANIMATION_MODE_RANDOM:     display_animation_random ();    break;
        default:                        display_animation_none ();      break;
    }
}

#if WCLOCK24H == 1                                                          // yet only available on WC24H
/*-------------------------------------------------------------------------------------------------------------------------------------------
 * display temperature
 *
 *   index ==   0  ->   0°C
 *   index == 250  -> 125°C
 *
 * the first temperature we can show is 10,0°C (index =  0, temperature_index ==  20)
 * the last  temperature we can show is 39,5°C (index = 79, temperature_index == 159)
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_temperature (uint_fast8_t power_is_on, uint_fast8_t temperature_index)
{
    uint_fast8_t   temp_mode = MODES_COUNT - 1;

    if (temperature_index >= 20 && temperature_index < 80)
    {
        uint8_t                         minute_mode;
        const struct MinuteDisplay *    tbl_minute;
        uint_fast16_t                   idx;

        temperature_index -= 20;                                            // subtract 10°C (20 units)

        // Perhaps not all LEDs have reached the desired colors yet.
        // This happens when we change the time faster than LED fading is.
        // Then we have to flush the target states:

        display_animation_flush (FALSE);

        // Now all LEDs have the desired colors of last time.
        // We can now set the new values:

        minute_mode = tbl_modes[temp_mode].minute_txt;
        tbl_minute  = &tbl_minutes[minute_mode][temperature_index];

        display_reset_led_states ();

        if (power_is_on)
        {
            display_word_on (WP_ES);
            display_word_on (WP_IST);

            for (idx = 0; idx < MAX_MINUTE_WORDS && tbl_minute->wordIdx[idx] != 0; idx++)
            {
                display_word_on (tbl_minute->wordIdx[idx]);
            }
        }

        animation_start_flag = 1;
    }
}

#else

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * display temperature as banner text (WC12h)
 *
 *   index ==   0  ->   0°C
 *   index == 250  -> 125°C
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_temperature (uint_fast8_t power_is_on, uint_fast8_t temperature_index)
{
    char                            banner_text[16];
    char *                          p;
    uint_fast8_t                    temp;
    uint_fast8_t                    temp_fraction;

    temp = temperature_index / 2;
    temp_fraction = temperature_index % 2;

    sprintf (banner_text, "  %u", temp);

    for (p = banner_text; *p; p++)
    {
        ;
    }

    if (temp_fraction)
    {
        *p++ = '.';
        *p++ = '5';
    }

    *p++ = BANNER_DEGREE;
    *p++ = 'C';
    *p   = '\0';

    // Perhaps not all LEDs have reached the desired colors yet.
    // This happens when we change the time faster than LED fading is.
    // Then we have to flush the target states:

    display_animation_flush (FALSE);

    // Now all LEDs have the desired colors of last time.
    // We can now set the new values:

    display_reset_led_states ();

    if (power_is_on)
    {
        display_banner (banner_text);
    }
}
#endif

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * display clock time
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_clock (uint_fast8_t power_is_on, uint_fast8_t hour, uint_fast8_t minute, uint_fast8_t display_flag)
{
    static uint8_t                  words[WP_COUNT];
    uint8_t                         hour_mode;
    uint8_t                         minute_mode;
#if WCLOCK24H == 1
    const struct MinuteDisplay *    tbl_minute;
#else
    const struct MinuteDisplay12 *  tbl_minute;
#endif
    const uint8_t *                 word_idx_p;
    uint_fast16_t                   idx;

    if (display_flag)
    {
        // Perhaps not all LEDs have reached the desired colors yet.
        // This happens when we change the time faster than LED fading is.
        // Then we have to flush the target states:

        display_animation_flush (FALSE);

        // Now all LEDs have the desired colors of last time.
        // We can now set the new values:

#if WCLOCK24H == 1
        minute_mode = tbl_modes[display_mode].minute_txt;
        tbl_minute  = &tbl_minutes[minute_mode][minute];
        hour_mode   = tbl_modes[display_mode].hour_txt;
#else
        display_minute_leds (power_is_on, minute);
        minute_mode = display_mode;
        tbl_minute  = &tbl_minutes[minute_mode][minute / 5];
        hour_mode   = tbl_minute->hour_mode;
#endif

        if (display_flag == DISPLAY_FLAG_UPDATE_ALL)
        {
            memset (words, 0, WP_COUNT);
            display_reset_led_states ();

            if (power_is_on)
            {
                words[WP_ES] = 1;
                words[WP_IST] = 1;

                for (idx = 0; idx < MAX_MINUTE_WORDS && tbl_minute->wordIdx[idx] != 0; idx++)
                {
                    words[tbl_minute->wordIdx[idx]] = 1;
                }

#if WCLOCK24H == 0                                                          // WC12h: we have only 12 hours
                if (hour >= HOUR_COUNT)
                {
                    hour -= HOUR_COUNT;
                }
#endif

                hour += tbl_minute->hourOffset;                             // correct the hour offset from the minutes

                if (hour >= HOUR_COUNT)
                {
                    hour -= HOUR_COUNT;
                }

                word_idx_p = tbl_hours[hour_mode][hour];                    // get the hour words from hour table

                for (idx = 0; idx < MAX_HOUR_WORDS && word_idx_p[idx] != 0; idx++)
                {
                    words[word_idx_p[idx]] = 1;
                }

                for (idx = 0; idx < WP_COUNT; idx++)
                {
                    if (words[idx])
                    {
                        display_word_on (idx);
                    }
                }
            }

            animation_start_flag = 1;
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * get display mode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_get_display_mode (void)
{
    return display_mode;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * set display mode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_set_display_mode (uint_fast8_t new_mode)
{
    if (new_mode < MODES_COUNT)
    {
        display_mode = new_mode;
        animation_start_flag = 1;
    }
    return display_mode;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * increment display mode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_increment_display_mode (void)
{
    if (display_mode < MODES_COUNT - 1)
    {
        display_mode++;
    }
    else
    {
        display_mode = 0;
    }

    animation_start_flag = 1;
    return display_mode;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * decrement display mode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_decrement_display_mode (void)
{
    if (display_mode == 0)
    {
        display_mode = MODES_COUNT - 1;
    }
    else
    {
        display_mode--;
    }

    animation_start_flag = 1;
    return display_mode;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * get automatic brightness control flag
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_get_automatic_brightness_control (void)
{
    return automatic_brightness_control;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * set automatic brightness control flag
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_set_automatic_brightness_control (uint_fast8_t new_automatic_brightness_control)
{
    automatic_brightness_control = new_automatic_brightness_control;

    if (! automatic_brightness_control)
    {
        display_set_brightness (MAX_BRIGHTNESS);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * get animation mode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_get_animation_mode (void)
{
    return animation_mode;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * set animation mode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_set_animation_mode (uint_fast8_t new_mode)
{
    if (new_mode < ANIMATION_MODES)
    {
        animation_mode = new_mode;
    }
    return animation_mode;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * increment animation mode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_increment_animation_mode (void)
{
    if (animation_mode < ANIMATION_MODES - 1)
    {
        animation_mode++;
    }
    else
    {
        animation_mode = 0;
    }

    return animation_mode;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * decrement animation mode
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_decrement_animation_mode (void)
{
    if (animation_mode == 0)
    {
        animation_mode = ANIMATION_MODES - 1;
    }
    else
    {
        animation_mode--;
    }

    return animation_mode;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * calculate dimmed colors
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
static void
display_calc_dimmed_colors ()
{
    static uint8_t  b[16] = { 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15 };
    uint_fast8_t    factor;

    if (brightness == MAX_BRIGHTNESS)
    {
        dimmed_colors.red   = current_colors.red;
        dimmed_colors.green = current_colors.green;
        dimmed_colors.blue  = current_colors.blue;
    }
    else
    {
        factor = b[brightness];

        dimmed_colors.red = (current_colors.red * factor) / MAX_BRIGHTNESS;

        if (current_colors.red > 0 && dimmed_colors.red == 0)
        {
            dimmed_colors.red = 1;
        }

        dimmed_colors.green = (current_colors.green * factor) / MAX_BRIGHTNESS;

        if (current_colors.green > 0 && dimmed_colors.green == 0)
        {
            dimmed_colors.green = 1;
        }

        dimmed_colors.blue = (current_colors.blue * factor) / MAX_BRIGHTNESS;

        if (current_colors.blue > 0 && dimmed_colors.blue == 0)
        {
            dimmed_colors.blue = 1;
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * increment red color by 2
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_increment_color_red (void)
{
    if (current_colors.red < MAX_COLOR_STEPS - 1)
    {
        current_colors.red++;

        if (current_colors.red < MAX_COLOR_STEPS - 1)
        {
            current_colors.red++;
        }

        display_calc_dimmed_colors ();
        display_animation_flush (TRUE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * decrement red color by 2
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_decrement_color_red (void)
{
    if (current_colors.red > 0)
    {
        current_colors.red--;

        if (current_colors.red > 0)
        {
            current_colors.red--;
        }

        display_calc_dimmed_colors ();
        display_animation_flush (TRUE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * increment green color by 2
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_increment_color_green (void)
{
    if (current_colors.green < MAX_COLOR_STEPS - 1)
    {
        current_colors.green++;

        if (current_colors.green < MAX_COLOR_STEPS - 1)
        {
            current_colors.green++;
        }

        display_calc_dimmed_colors ();
        display_animation_flush (TRUE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * decrement green color by 2
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_decrement_color_green (void)
{
    if (current_colors.green > 0)
    {
        current_colors.green--;

        if (current_colors.green > 0)
        {
            current_colors.green--;
        }

        display_calc_dimmed_colors ();
        display_animation_flush (TRUE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * increment blue color by 2
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_increment_color_blue (void)
{
    if (current_colors.blue < MAX_COLOR_STEPS - 1)
    {
        current_colors.blue++;

        if (current_colors.blue < MAX_COLOR_STEPS - 1)
        {
            current_colors.blue++;
        }

        display_calc_dimmed_colors ();
        display_animation_flush (TRUE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * decrement blue color by 2
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_decrement_color_blue (void)
{
    if (current_colors.blue > 0)
    {
        current_colors.blue--;

        if (current_colors.blue > 0)
        {
            current_colors.blue--;
        }

        display_calc_dimmed_colors ();
        display_animation_flush (TRUE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * get colors
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_get_colors (DSP_COLORS * rgb)
{
    rgb->red    = current_colors.red;
    rgb->green  = current_colors.green;
    rgb->blue   = current_colors.blue;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * set colors
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_set_colors (DSP_COLORS * rgb)
{
    current_colors.red      = (rgb->red < MAX_COLOR_STEPS)   ? rgb->red : MAX_COLOR_STEPS;
    current_colors.green    = (rgb->green < MAX_COLOR_STEPS) ? rgb->green : MAX_COLOR_STEPS;
    current_colors.blue     = (rgb->blue < MAX_COLOR_STEPS)  ? rgb->blue : MAX_COLOR_STEPS;

    display_calc_dimmed_colors ();
    display_animation_flush (TRUE);
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * get brightness
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_get_brightness (void)
{
    return brightness;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * set brightness
 *  MAX_BRIGHTNESS  = full brightness
 *   0              = lowest brightness
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_set_brightness (uint_fast8_t new_brightness)
{
    if (new_brightness > MAX_BRIGHTNESS)
    {
        brightness = MAX_BRIGHTNESS;
    }
    else
    {
        brightness = new_brightness;
    }

    display_calc_dimmed_colors ();
    display_animation_flush (TRUE);
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * decrement brightness
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_decrement_brightness (void)
{
    if (brightness > 0)
    {
        brightness--;
        display_calc_dimmed_colors ();
        display_animation_flush (TRUE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * increment brightness
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_increment_brightness (void)
{
    if (brightness < MAX_BRIGHTNESS)
    {
        brightness++;
        display_calc_dimmed_colors ();
        display_animation_flush (TRUE);
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * Test all LEDs
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_test (void)
{
    LED_RGB      rgb;
    uint_fast16_t   i;
    uint_fast16_t   j;

    for (i = 1; i < 8; i++)
    {
        rgb.red     = (i & 0x01) ? pwmtable8[MAX_COLOR_STEPS / 2] : 0;
        rgb.green   = (i & 0x02) ? pwmtable8[MAX_COLOR_STEPS / 2] : 0;
        rgb.blue    = (i & 0x04) ? pwmtable8[MAX_COLOR_STEPS / 2] : 0;

        for (j = 0; j < DSP_MAX_LEDS; j++)
        {
            led_set_led (j, &rgb);
        }

        display_refresh_ambilight_leds ();
        delay_sec (3);
    }

    display_animation_flush (FALSE);
    display_set_status_led (0, 0, 0);
}

#if USE_FONT == 1
static void
display_show_message_char (uint_fast8_t start_line, uint_fast8_t start_col, unsigned char ch, uint_fast8_t col_offset)
{
    uint_fast8_t    line;
    uint_fast8_t    col;
    uint_fast8_t    offset;

    for (line = 0; line < FONT_LINES; line++)
    {
        offset = col_offset;

        for (col = 0; offset < FONT_COLS; col++, offset++)
        {
            if (start_line + line < WC_ROWS && start_col + col < WC_COLUMNS)
            {
                if (font[ch][line] & (1<<(FONT_COLS - offset)))
                {
                    led.matrix[start_line + line][start_col + col] = NEW_STATE;
                }
                else
                {
                    led.matrix[start_line + line][start_col + col] = CURRENT_STATE;
                }
            }
        }

        while (start_col + col < WC_COLUMNS)
        {
            led.matrix[start_line + line][start_col + col] = CURRENT_STATE;
            col++;
        }
    }
}

static void
display_message_with_offset (unsigned char * str, uint_fast8_t n)
{
    uint_fast8_t     start_line;
    uint_fast8_t     start_col;

    start_line = (WC_ROWS - FONT_LINES) / 2;
    start_col = 0;

    display_show_message_char (start_line, start_col, *str, n);

    str++;
    start_col = FONT_COLS - n;

    while (*str && start_col < WC_COLUMNS)
    {
        display_show_message_char (start_line, start_col, *str++, 0);
        start_col += FONT_COLS + 1;                                         // +1 = gap between letters
    }

    while (start_col < WC_COLUMNS)
    {
        display_show_message_char (start_line, start_col, ' ', 0);
        start_col += FONT_COLS + 1;                                         // +1 = gap between letters
    }

    display_show_new_display ();
}


/*-------------------------------------------------------------------------------------------------------------------------------------------
 * Display message
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_message (char * str)
{
    uint_fast8_t    n;
    unsigned char * p;

    display_reset_led_states ();

    for (p = (unsigned char *) str; *p; p++)
    {
        for (n = 0; n < FONT_COLS; n++)
        {
            display_message_with_offset (p, n);
            delay_msec (50);
        }
    }
}

#endif // USE_FONT

static void
display_show_banner_char (uint_fast8_t start_line, uint_fast8_t start_col, unsigned char ch, uint_fast8_t col_offset)
{
    uint_fast8_t    line;
    uint_fast8_t    col;
    uint_fast8_t    offset;

    if (ch >= 128)
    {
        switch (ch)
        {
            case 0xe4: case 0xc4:   ch = BANNER_A_UMLAUT;   break;
            case 0xf6: case 0xd6:   ch = BANNER_O_UMLAUT;   break;
            case 0xfc: case 0xdc:   ch = BANNER_U_UMLAUT;   break;
            case 0xdf:              ch = BANNER_SHARP_S;    break;
            case 0xb0:              ch = BANNER_DEGREE;     break;
            default:                ch = ' ';               break;
        }
    }

    for (line = 0; line < BANNER_LINES; line++)
    {
        offset = col_offset;

        for (col = 0; offset < BANNER_COLS; col++, offset++)
        {
            if (start_line + line < WC_ROWS && start_col + col < WC_COLUMNS)
            {
                if (banner[ch][line] & (1<<(BANNER_COLS - 1 - offset)))
                {
                    led.matrix[start_line + line][start_col + col] = NEW_STATE;
                }
                else
                {
                    led.matrix[start_line + line][start_col + col] = CURRENT_STATE;
                }
            }
        }

        while (start_col + col < WC_COLUMNS)
        {
            led.matrix[start_line + line][start_col + col] = CURRENT_STATE;
            col++;
        }
    }
}

static void
display_banner_with_offset (unsigned char * str, uint_fast8_t n)
{
    uint_fast8_t     start_line;
    uint_fast8_t     start_col;

    start_line = (WC_ROWS - BANNER_LINES) / 2;
    start_col  = 0;

    display_show_banner_char (start_line, start_col, *str, n);

    str++;
    start_col = BANNER_COLS - n;

    while (*str && start_col < WC_COLUMNS)
    {
        display_show_banner_char (start_line, start_col, *str++, 0);
        start_col += BANNER_COLS + 1;                                       // +1 = gap between letters
    }

    while (start_col < WC_COLUMNS)
    {
        display_show_banner_char (start_line, start_col, ' ', 0);
        start_col += BANNER_COLS + 1;                                       // +1 = gap between letters
    }

    display_show_new_display ();
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * Display banner
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_banner (char * str)
{
    uint_fast8_t    n;
    unsigned char * p;

    display_reset_led_states ();

    for (p = (unsigned char *) str; *p; p++)
    {
        for (n = 0; n < BANNER_COLS; n++)
        {
            display_banner_with_offset (p, n);
            delay_msec (50);
        }
    }
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * read configuration from EEPROM
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_read_config_from_eeprom (void)
{
    uint_fast8_t            rtc = 0;
    PACKED_DSP_COLORS       packed_rgb_color;
    uint8_t                 display_mode8;
    uint8_t                 animation_mode8;
    uint8_t                 brightness8;
    uint8_t                 automatic_brightness_control8;

    if (eeprom_is_up)
    {
        if (eeprom_read (EEPROM_DATA_OFFSET_DSP_COLORS, (uint8_t *) &packed_rgb_color, sizeof(PACKED_DSP_COLORS)) &&
            eeprom_read (EEPROM_DATA_OFFSET_DISPLAY_MODE, &display_mode8, sizeof(display_mode8)) &&
            eeprom_read (EEPROM_DATA_OFFSET_ANIMATION_MODE, &animation_mode8, sizeof(animation_mode8)) &&
            eeprom_read (EEPROM_DATA_OFFSET_BRIGHTNESS, &brightness8, EEPROM_DATA_SIZE_BRIGHTNESS) &&
            eeprom_read (EEPROM_DATA_OFFSET_AUTO_BRIGHTNESS, &automatic_brightness_control8, EEPROM_DATA_SIZE_AUTO_BRIGHTNESS))
        {
            if (display_mode8 >= MODES_COUNT)
            {
                display_mode8 = 0;
            }

            if (animation_mode8 >= ANIMATION_MODES)
            {
                animation_mode8 = 0;
            }

            if (brightness8 > MAX_BRIGHTNESS)
            {
                brightness8 = MAX_BRIGHTNESS;
            }

            if (automatic_brightness_control8 != 0x01)        // only 0x00 or 0x01 allowed, 0xFF means empty EEPROM
            {
                automatic_brightness_control8 = 0;
            }

            current_colors.red              = packed_rgb_color.red;
            current_colors.green            = packed_rgb_color.green;
            current_colors.blue             = packed_rgb_color.blue;
            display_mode                    = display_mode8;
            animation_mode                  = animation_mode8;
            brightness                      = brightness8;
            automatic_brightness_control    = automatic_brightness_control8;

            display_calc_dimmed_colors ();

            rtc = 1;
        }
    }

    return rtc;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * write configuration to EEPROM
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
display_write_config_to_eeprom (void)
{
    uint_fast8_t            rtc = 0;
    PACKED_DSP_COLORS       packed_rgb_color;
    uint8_t                 display_mode8;
    uint8_t                 animation_mode8;
    uint8_t                 brightness8;
    uint8_t                 automatic_brightness_control8;

    packed_rgb_color.red            = current_colors.red;
    packed_rgb_color.green          = current_colors.green;
    packed_rgb_color.blue           = current_colors.blue;

    display_mode8                   = display_mode;
    animation_mode8                 = animation_mode;
    brightness8                     = brightness;
    automatic_brightness_control8   = automatic_brightness_control;

    if (eeprom_is_up)
    {
        if (eeprom_write (EEPROM_DATA_OFFSET_DSP_COLORS, (uint8_t *) &packed_rgb_color, sizeof(PACKED_DSP_COLORS)) &&
            eeprom_write (EEPROM_DATA_OFFSET_DISPLAY_MODE, &display_mode8, sizeof(display_mode8)) &&
            eeprom_write (EEPROM_DATA_OFFSET_ANIMATION_MODE, &animation_mode8, sizeof(animation_mode8)) &&
            eeprom_write (EEPROM_DATA_OFFSET_BRIGHTNESS, &brightness8, EEPROM_DATA_SIZE_BRIGHTNESS) &&
            eeprom_write (EEPROM_DATA_OFFSET_AUTO_BRIGHTNESS, &automatic_brightness_control8, EEPROM_DATA_SIZE_AUTO_BRIGHTNESS))

        {
            rtc = 1;
        }
    }

    return rtc;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
 * initialize LED display
 *-------------------------------------------------------------------------------------------------------------------------------------------
 */
void
display_init (void)
{
    led_init ();
}
